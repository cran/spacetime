% Discussion, add:
%  no type (field, object? point pattern or geostat?)
%  more ST types available (Galton 2008)
% Graphs: move up, add all types.

% panel data: do plm analysis on STFDF object?
%
% time from point -> interval; can this be done generic?
% figures:
% - what is implicitly the time interval?
% - how do the classes look like on a s x t plot?
% - reduction / simplification if t is regular - how does that work?
%  as.ts? in zoo?
% TODO:
%  over, aggregate, interpolate?
% http://www.data.gov/raw/1424#

% Fri Jan 20 15:34:43 CET 2012; review round 1 from JSS.

%\documentclass[nogin,a4paper]{article}
\documentclass[article]{jss}

%\usepackage[OT1]{fontenc}

%\usepackage[colorlinks=true,urlcolor=blue]{hyperref}
%% need no \usepackage{Sweave.sty}
\usepackage[utf8]{inputenc}

\title{\bf Spatio-Temporal Data in {\tt R}}

\Shorttitle{Spatio-Temporal Data in \proglang{R}}

\author{
Edzer Pebesma \\
\includegraphics[width=5cm]{ifgi-logo_int}
}
%\date{\small \today }
\Address{
Edzer Pebesma\\
Institute for Geoinformatics, University of M\"{u}nster\\
Weseler Strasse 253, M\"{u}nster, Germany\\
E-mail: \email{edzer.pebesma@uni-muenster.de}\\
URL: \url{http://ifgi.uni-muenster.de/}
}

\Abstract{
This document describes classes and methods designed to deal with
different types of spatio-temporal data in \proglang{R} implemented
in the \proglang{R} package \pkg{spacetime}, and provides examples
for analyzing them. It builds upon the classes and methods for
spatial data from package \pkg{sp}, and for time series data
from package \pkg{xts}.  The goal is to cover a number of useful
representations for spatio-temporal sensor data, and results from
predicting (spatial and/or temporal interpolation or smoothing),
aggregating, or subsetting them, and to represent trajectories.
The goals of this paper is to explore how spatio-temporal data can
be sensibly represented in classes, and to find out which analysis
and visualisation methods are useful and feasible.  We discuss
the convention of representing time intervals by the starting time
instance.  This document is the main reference for the \proglang{R}
package \code{spacetime}, and is available (in updated form) as a
vignette in this package.

}

\Keywords{Time series analysis, spatial data, spatio-temporal statistics, GIS}

\begin{document}
% \VignetteIndexEntry{ spacetime: Spatio-Temporal Data in R }
% jss options, see http://www.jstatsoft.org/style
<<eval=TRUE,echo=FALSE>>=
options(prompt = "R> ", continue = "+  ", width = 70, useFancyQuotes = FALSE)
@
\maketitle

%\tableofcontents

\section{Introduction}

Spatio-temporal data are abundant, and easily obtained. Examples are
satellite images of parts of the earth, temperature readings for a
number of nearby stations, election results for voting districts
and a number of consecutive elections, GPS tracks for people or
animals possibly with additional sensor readings, disease outbreaks
or volcano eruptions.

\cite{schabenberger} argue that analysis of spatio-temporal data
often happens {\em conditionally}, meaning that either first the
spatial aspect is analysed, after which the temporal aspects are
analysed, or reversed, but not in a joint, integral modelling
approach, where space and time are not separated.  As a possible
reason they mention the lack of good software, data classes
and methods to handle, import, export, display and analyse such
data. This \proglang{R} \citep{RR} package is a start to fill this gap.

Spatio-temporal data are often relatively abundant in either
space, or time, but not in both. Satellite imagery is typically very
abundant in space, giving lots of detail in high spatial resolution
for large areas, but relatively sparse in time. Analysis of repeated
images over time may further be hindered by difference in light
conditions, errors in georeferencing resulting in spatial mismatch,
and changes in obscured areas due to changed cloud coverage. On
the other side, data from fixed sensors give often very detailed
signals over time, allowing for elaborate modelling, but relatively
little detail in space because a very limited number of sensors is
available. The cost of an in situ sensor network typically depends
primarily on its spatial density; the choice of the temporal
resolution with which the sensors register signals may have little
effect on total cost.

Although for example \cite{botts} describe a number of open standards
that allow the interaction with sensor data (describing sensor
characteristics, requesting observed values, planning sensors, and
processing raw sensed data to predefined events), the available
statistical or GIS software for this is in an early stage, and
scattered. This paper describes an attempt to combine available
infrastructure in the \proglang{R} statistical environment to a
set of useful classes and methods for manipulating, plotting and
analysing spatio-temporal data. A number of case studies from
different application areas will illustrate its use.

The paper is structured as follows. Section 2 describes how
spatio-temporal data are usually recorded in tables. Section 3
describes a number of useful spatio-temporal layouts. Section 4
introduces classes and methods for data, based on these layouts.
Section 5 presents a number of useful graphs for spatio-temporal
data, and implementations for these. Section 6 discusses the
spatial and temporal footprint, or support, of data, and how
time intervals are dealt with in practice.  Section 7 presents a
number of worked examples, some of which include statistical analysis
on the spatio-temporal data.  Section 8 points to further material,
including vignettes in package \pkg{spacetime}\footnote{ This
paper is available (in updated form) as vignette from this package,
which implements the classes and methods for spatio-temporal data
described here. } on spatio-temporal overlay and aggregation, and
on using proxy data sets to PostgreSQL tables that are too large
to fit in memory for R.  Section 9 finishes with a discussion.

%\section{Space-time data in wide and long formats}
\section{How spatio-temporal data are recorded in tables}
\label{sec:longwide}
For reasons of simplicity, spatio-temporal data often come in the
form of single tables. If this is the case, they come in one of three
forms: 
\begin{description}
\item[time-wide] where different columns reflect different moments
in time, 
\item[space-wide] where different columns reflect different measurement
locations or areas, or
\item[long formats] where each record reflects a single time and space
combination.
\end{description}
Alternatively, they may be stored in different, related tables,
which is more typical for relational data bases, or in tree
structures which is typical for xml files.  We will now illustrate
the different single-table formats with simple examples.

\subsection{Time-wide format}
Spatio-temporal data for which each location has data for each time
can be provided in two so-called {\bf wide formats}. An example
where a single column refers to a single moment or period in time is found
in the North Carolina Sudden Infant Death Syndrome (sids) data set, 
which is in the {\bf time-wide format}:
<<>>=
library("foreign")
read.dbf(system.file("shapes/sids.dbf", package="maptools"))[1:5,c(5,9:14)]
@
where {\bf columns} refer to a particular {\bf time}: \code{SID74}
contains to the infant death syndrome cases for each county at a
particular time period (1974-1978).

\subsection{Space-wide format}
The Irish wind data \citep{haslett}, for which the first six
records and 9 of the stations (abbreviated by \code{RPT},
\code{VAL}, ...) are shown by
<<>>=
data("wind", package = "gstat")
wind[1:6,1:12]
@
are in {\bf space-wide format}: each {\em column} refers to another
wind measurement {\bf location}, and the rows reflect a single
time period; wind was reported as daily average wind speed in knots
(1 knot = 0.5418 m/s).

\subsection{Long format}
Finally, panel data are shown in {\bf long form}, where the full
spatio-temporal information is held in a single column, and other columns
denote location and time. In the
\code{Produc} data set \citep{baltagi}, a panel of 48 observations
from 1970 to 1986 available in the \pkg{plm} package \citep{croissant}, 
the first five records and nine columns are
<<>>=
data("Produc", package = "plm")
Produc[1:5,1:9]
@
where the first two columns denote space and time (the default
assumption for package \pkg{plm}), and e.g., \code{pcap} reflects
private capital stock.

None of these examples has strongly {\em referenced} spatial or
temporal information: it is from the data alone not clear that
the number \code{1970} refers to a year, or that \code{ALABAMA}
refers to a state, and where this state is.  Section \ref{sec:cases}
shows for each of these three cases how the data can be converted
into classes with strongly referenced space and time information.

\section{Space-time layouts}

In the following we will use the word spatial {\em feature}
\citep{sfs} to denote a spatial entity. This can be a particular
spatial point (location), a line or set of lines, a polygon or set
of polygons, or a pixel (grid or raster cell). For a particular
feature, one or more measurements are registered at particular
moments in time.

Four layouts of space-time data will be discussed next.  Two of them
reflect lattice layouts, one that is efficient when a particular
spatial feature has data values for more than one time point,
and one that is most efficient when all spatial feature have data
values at each time point. Two others reflect irregular layouts,
one of them specializes to trajectories.

\begin{figure} %[htb]
\begin{center}
<<fig=TRUE,echo=FALSE,height=6,width=6>>=
opar = par()
par(mfrow=c(2,2))
# 1:
s = 1:3
t = c(1, 1.75, 3, 4.5)
g = data.frame(rep(t, each=3), rep(s,4))
col = 'blue'
pch = 16
plot(g, xaxt = 'n', yaxt = 'n', xlab = "Time points",
    ylab = "Spatial features", xlim = c(.5,5.5), ylim = c(.5,3.5),
	pch = pch, col = col)
abline(h=s, col = grey(.8))
abline(v=t, col = grey(.8))
points(g)
axis(1, at = t, labels = c("1st", "2nd", "3rd", "4th"))
axis(2, at = s, labels = c("1st", "2nd", "3rd"))
text(g, labels = 1:12, pos=4)
title("STF: full grid layout")
# 2:
s = 1:3
t = c(1, 2.2, 3, 4.5)
g = data.frame(rep(t, each=3), rep(s,4))
sel = c(1,2,3,5,6,7,11)
plot(g[sel,], xaxt = 'n', yaxt = 'n', xlab = "Time points",
    ylab = "Spatial features", xlim = c(.5,5.5), ylim = c(.5,3.5),
	pch = pch, col = col)
abline(h=s, col = grey(.8))
abline(v=t, col = grey(.8))
points(g[sel,])
axis(1, at = t, labels = c("1st", "2nd", "3rd", "4th"))
axis(2, at = s, labels = c("1st", "2nd", "3rd"))
text(g[sel,], labels = paste(1:length(sel), "[",c(1,2,3,2,3,1,2),",",c(1,1,1,2, 2,3,4),"]", sep=""), pos=4)
title("STS: sparse grid layout")
# 3:
s = c(1,2,3,1,4)
t = c(1, 2.2, 2.5, 4, 4.5)
g = data.frame(t,s)
plot(g, xaxt = 'n', yaxt = 'n', xlab = "Time points",                
    ylab = "Spatial features", xlim = c(.5,5.5), ylim = c(.5,4.5),
	pch = pch, col = col)
#abline(h=s, col = grey(.8))
#abline(v=t, col = grey(.8))
arrows(t,s,0.5,s,.1,col='red')
arrows(t,s,t,0.5,.1,col='red')
points(g)
axis(1, at = sort(unique(t)), labels = c("1st", "2nd", "3rd", "4th", "5th"))
axis(2, at = sort(unique(s)), labels = c("1st,4th", "2nd", "3rd", "5th"))
text(g, labels = 1:5, pos=4)
title("STI: irregular layout")
# 4: traj
ns = 400
nt = 100
s = sort(runif(ns))
t = sort(runif(nt))
g = data.frame(t[1:30],s[1:30])
plot(g, xaxt = 'n', yaxt = 'n', xlab = "Time points",                
    ylab = "Spatial features", 
	type='l', col = 'blue', xlim = c(0,1), ylim = c(0,s[136]))
lines(data.frame(t[41:60],s[31:50]), col = 'blue')
lines(data.frame(t[91:100],s[51:60]), col = 'blue')
lines(data.frame(t[21:40],s[61:80]), col = 'red')
lines(data.frame(t[51:90],s[81:120]), col = 'red')
lines(data.frame(t[11:25],s[121:135]), col = 'green')
#abline(h=s, col = grey(.8))
#abline(v=t, col = grey(.8))
#arrows(t,s,0.5,s,.1,col='red')
#arrows(t,s,t,0.5,.1,col='red')
axis(1, at = sort(unique(t)), labels = rep("", length(t)))
axis(2, at = sort(unique(s)), labels = rep("", length(s)))
#text(g, labels = 1:5, pos=4)
title("STT: trajectory")
opar$cin = opar$cra = opar$csi = opar$cxy = opar$din = NULL
par(opar)
@
\end{center}
\caption{Space-time layouts: (i) the top-left: full grid (\code{STF})
layout stores all space-time combinations; (ii) top-right: the
sparse grid (\code{STS}) layout stores only the non-missing
space-time combinations on a lattice; (iii) bottom-left: the
irregular (\code{STI}) layout: each observation has its spatial
feature and time stamp stored, in this example, spatial feature 1
is stored twice -- the fact that observations 1 and 4 have the same
feature is not registered; (iv) bottom right: simple trajectories
(\code{STT}), plotted against a common time axis. It should be noted
that in both {\em gridded} layouts the grid is in space-time, meaning
that spatial features {\em can} be gridded, but can also be any other
non-gridded type (lines, points, polygons). }
\label{fig:st}
\end{figure}

\subsection{Spatio-temporal full grids}

A full space-time grid of observations for spatial features (points,
lines, polygons, grid cells)\footnote{note that neither spatial
features nor time points need to follow a regular layout} $s_i, i =
1,...,n$ and observation time $t_j, j = 1,...,m$ is obtained when
the full set of $n \times m$ set of observations $z_k$ is stored,
with $k=1,...,nm$. We choose to cycle spatial features first,
so observation $k$ corresponds to feature $s_i$, $i=((k-1)\ \%\
n) + 1$ and with time moment $t_j$, $j=((k-1) / n)+ 1$, with $/$
integer division and \% integer division remainder (modulo). The
$t_j$ are assumed to be in time order.

In this data class (top left in figure \ref{fig:st}), for each spatial
feature, the same temporal sequence of data is sampled. Alternatively
one could say that for each moment in time, the same set of spatial
entities is sampled.  Unsampled combinations of (space, time)
are stored in this class, but are assigned a missing value \code{NA}.

It should be stressed that for this class (and the next) the word
{\em grid} in {\em spatio-temporal grid} refers to the layout in
space-time, not in space. Examples of phenomena that could well be
represented by this class are regular (e.g.  hourly) measurements
of air quality at a spatially irregular set of points (measurement
stations), or yearly disease counts for a set of administrative
regions. An example where space is {\em gridded} as well could be
a sequence of rainfall images (e.g. monthly sums), interpolated to
a spatially regular grid.

\subsection{Spatio-temporal sparse grids}
A sparse grid has the same general layout, with measurements laid
out on a space time grid (top right in figure \ref{fig:st}), but instead of
storing the full grid, only non-missing valued observations $z_{k}$
are stored. For each $k$, an index $[i,j]$ is stored that refers
which spatial feature $i$ and time point $j$ the value belongs to.

Storing data this way may be efficient 
\begin{itemize}
\item if full space-time lattices have many missing or trivial values 
(e.g. when one want to store features or grid cells where fires were
registered, discarding those that did not), or
\item if a limited set of spatial features each have different 
time instances (e.g. to record the times of crime cases for a set
of administrative regions), or 
\item if for a limited set of times the set of spatial features varies 
(e.g. locations of crimes registered per year, or spatially 
misaligned remote sensing images).
\end{itemize}

\subsection{Spatio-temporal irregular data}

Space-time irregular data cover the case where time and space points
of measured values have no apparent organisation: for each measured
value the spatial feature and time point is stored, as in the long
format. This is equivalent to the (maximally) sparse grid where the
index for observation $k$ is $[k,k]$, and hence can be dropped. For
these objects, $n=m$ equals the number of records.  Spatial features
and time points need not be unique, but are replicated in case they
are not.

Any of the gridded types can be represented by this layout,
in principle, but this would have the disadvantages that
\begin{itemize}
\item spatial features and time points need to be stored for each data value,
and would be redundant
\item the regular layout is lost, and needs be retrieved indirectly
\item if time reflects time intervals, the interval is not obvious anymore
\item spatial and temporal selection would be inefficient, as the grid
structure works effectively as an index.
\end{itemize}

Examples of phenomena that are best served by this layout could
be spatio-temporal point processes, such as crime or disease cases
or forest fires. Other phenomena could be measurements from mobile
sensors (when the trajectory sequence is not of importance).

\subsection{Spatio-temporal trajectories}

Trajectories cover the case where sets of (irregular) space-time
points form sequences, and depict a trajectory. The grouping may
be simple (e.g. the trajectories of two persons on different days),
nested (for several objects, a set of trajectories representing
different trips) or complex (e.g. with objects that split, merge,
or disappear). 

Examples of trajectories can be human trajectories, mobile sensor
measurements (where the sequence is kept, e.g. to derive the speed
and direction of the sensor), or trajectories of tornados where the
tornado extent of each time stamp can be reflected by a different
polygon.

\section{Classes and methods for spatio-temporal data}

The different layouts, or types, of spatio-temporal data discussed in
the previous section have been implemented in the \pkg{spacetime}
\proglang{R} package, along with methods for import, export, coercion,
selection, and visualisation.

\subsection{Classes}
The classes for the different layouts are shown in figure \ref{cls}.
Similar to the classes of package \pkg{sp} \citep{bivand}, the classes all
derive from a base class \code{ST} which is not meant to represent
actual data. The first order derived classes specify particular
spatio-temporal geometries (i.e., only the spatial and temporal
information), the second order derived classes augment each of
these with actual data, in the form of a \code{data.frame}.
\begin{figure}[htb]
\begin{center}
\includegraphics[width=.4\columnwidth]{cls}
\end{center}
\caption{Classes for spatio-temporal data in package \pkg{spacetime}. Arrows
denote inheritance, lower side of boxes list slot name and type, green lines
indicate possible coercions (both ways). }
\label{cls}
\end{figure}
% is.regular. or not.

% is.gridded. is sth different: 2D

% what is wide and what is long format.
To store temporal information, we chose to use objects of class 
\code{xts} in package \pkg{xts} 
\citep{ryan} for time, because 
\begin{itemize}
\item it extends the functionality of package \pkg{zoo} \citep{zeileis},
\item it supports several basic types to represent time or date:
\code{Date}, \code{POSIXct}, \code{timeDate}, \code{yearmon}, and \code{yearqtr},
\item it has good tools for {\em aggregation}
over time using arbitrary aggregation functions, essentially
deriving this from package \code{zoo} \citep{zeileis}.
\item it has a flexible syntax to select time periods that adheres to ISO
8601\footnote{\url{http://en.wikipedia.org/wiki/ISO_8601}}.
\end{itemize}
An overview of the different time classes in \proglang{R} is found
in \cite{ripleyhornik}. Further advice on which classes to use is
found in \cite{grothendieck}, or in the
\href{http://cran.r-project.org/web/views/TimeSeries.html}{ CRAN
task view on time series analysis }.

For spatial interpolation, we used the classes deriving from \code{Spatial}
in package \pkg{sp} \citep{pebesma,bivand} because
\begin{itemize}
\item they are the dominant set of classes in \proglang{R} for dealing
with spatial data,
\item they are interfaced to key external libraries through packages
\pkg{rgdal} and \pkg{rgeos}, and
\item they provide a single interface to dealing with points, lines,
polygons and grids.
\end{itemize}
We do not use \code{xts} or \code{Spatial} objects to {\em store}
spatio-temporal data values, but we use \code{data.frame} to store
data values. For purely temporal information the \code{xts} objects
can be used, and for purely spatial information the \code{sp}
objects can be used. These will be recycled appropriately when
coercing to a long format \code{data.frame}.

The spatial features supported by package \pkg{sp} are
two-dimensional for lines and polygons, but may be higher (three-)
dimensional for spatial points, pixels and grids.

\subsection{Methods}
The main methods for spatio-temporal data implemented in packages
\pkg{spacetime} are listed in table \ref{methods}. Their usage is
illustrated in examples that follow.

\begin{table}
\begin{center}
\begin{tabular}{|lp{10cm}|} \hline
method & what it does \\ \hline
\code{stConstruct} & Creates STFDF or STIDF objects from single or multiple tables \\
\code{[[}, \code{\$}, \code{\$<-} & Select or replace data values \\
\code{[}, \code{[[}, \code{\$} & Select spatial and/or temporal sections \\
\code{as} & coerce to other spatio-temporal objects, \code{xts}, \code{Spatial},
\code{matrix}, or \code{data.frame} \\
\code{stplot} & create spatio-temporal plots, see section \ref{plots}  \\
\code{over} & overlay: retrieve index or data values of one object at the locations and times
of another \\
\code{aggregate} & aggregate data values over particular spatial, temporal,
or spatio-temporal domains \\ \hline
\end{tabular}
\end{center}
\caption{Methods for spatio-temporal data in package \pkg{spacetime}}
\label{methods}
\end{table}

\subsection{Creation}
Construction of spatio-temporal objects essentially needs specification
of the spatial, the temporal, and the data values. The documentation of
\code{stConstruct} contains examples of how this can be done from
long, space-wide, and time-wide tables, or from shapefiles. A simple
toy example for a full grid layout with three spatial points and four time 
instances is given below. First, the spatial object is created:
<<>>=
sp = cbind(x = c(0,0,1), y = c(0,1,1))
row.names(sp) = paste("point", 1:nrow(sp), sep="")
library(sp)
sp = SpatialPoints(sp)
@
Then, the time points are defined as four time stamps, one
hour apart, starting Aug 5 2010, 10:00 GMT.
<<>>=
time = as.POSIXct("2010-08-05", tz = "GMT")+3600*(10:13)
@
Next, a data.frame with the data values is created:
<<>>=
m = c(10,20,30) # means for each of the 3 point locations
values = rnorm(length(sp)*length(time), mean = rep(m, 4))
IDs = paste("ID",1:length(values), sep = "_")
mydata = data.frame(values = signif(values, 3), ID=IDs)
@
And finally, the \code{STFDF} object is created:
<<>>=
library(spacetime)
stfdf = STFDF(sp, time, mydata)
@
When given a long table, \code{stConstruct} creates by default
an object of class \code{STIDF}, which can then be coerced to
\code{STSDF} or \code{STFDF} when relevant.

\subsection{Overlay and aggregation}

Aggregation of data values to a coarser spatial or temporal form
(e.g., to a coarser grid, aggregating points over administrative
regions, aggregating daily data to monthly data, or aggregation
along an irregular set of space-time points) can be done using
the method \code{aggregate}.  To obtain the required aggregation
predicate, i.e. the grouping of observations in space-time,
the method \code{over} is implemented for objects deriving from
\code{ST}.  Grouping can be done based on spatial, temporal, or
spatio-temporal predicates.  It allows flexibility to whether
time reflects time instances or time intervals (see section
\ref{intervals}).  These methods effectively provide
a spatio-temporal equivalent to what is known in geographic
information science as the {\em spatial overlay}.

\subsection[Space and time selection]{Space and time selection with \code{[}}

The idea behind the \code{[} method for classes in \code{sp} was
that objects would behave as much as possible similar to {\em matrix}
and \code{data.frame}.  For a \code{data.frame}, a construct like
\code{a[i,j]} selects row(s) \code{i} and column(s) \code{j}. For
objects deriving from \code{Spatial}, rows were taken as the spatial
features (points, lines, polygons, pixels) and columns as the
data variables\footnote{a convention that was partially broken for class
\code{SpatialGridDataFrame}, where \code{a[i,j,k]} could select the
$k$-th data variable of the spatial grid selection with spatial grid
row(s) \code{i} and column(s) \code{j}, {\em unless} the length of
\code{i} equals the number of grid cells.}.

For the spatio-temporal data classes described here, \code{a[i,j,k]}
selects spatial features \code{i}, temporal instances \code{j},
and data variable(s) \code{k}.  Unless \code{drop=FALSE} is added
to such a call, selecting a single time or single feature results in
an object that is no longer spatio-temporal, but either {\em
snapshot} of a particular moment, or {\em history} at a particular
feature \citep{galton}.

Similar to selection on spatial objects in \pkg{sp} and time series
objects in \pkg{xts}, space and time indices can be defined by index
or boolean vectors, but also by higher-level expressions such as
spatial areas and time periods. For instance, the selection
<<eval=FALSE>>=
air_quality[2:3, 1:10, "PM10"]
@
yields air quality data for the second and third spatial features,
and the first 10 time instances. Higher-level spatial and temporal
expressions can be used, and
<<eval=FALSE>>=
air_quality[Germany, "2008::2009", "PM10"]
@
selects the \code{PM10} measurements for the years 2008-9, lying
in \code{Germany}, when \code{Germany} is a \code{Spatial} object
(e.g. \code{SpatialPolygons}, or a \code{SpatialGrid}) that defines
Germany.

\subsection[Coercion to long and wide tables]{Coercion to long
and wide tables}
Spatio-temporal data objects can be coerced to the corresponding
purely spatial objects.  Objects of class \code{STFDF} will be 
represented in time-wide form, where only the first (selected) data
variable is retained:
<<>>=
xs1 = as(stfdf, "Spatial")
class(xs1)
xs1
@
as time values are difficult to retrieve from these column names, 
this object gets the proper time values as an attribute:
<<>>=
attr(xs1, "time")
@
Objects of class \code{STSDF} or \code{STIDF} will be represented
in long form, where time is added as additional column:
<<>>=
x = as(stfdf, "STIDF")
xs2 = as(x, "Spatial")
class(xs2)
xs2[1:4,]
@

\section{Graphs of spatio-temporal data}
\label{plots}

\subsection[stplot: panels, space-time plots, animation]{\code{stplot}: panels, space-time plots, animation}
The \code{stplot} method can create a few specialized plot types
for the classes in the \code{spacetime} package. They are:
\begin{description}
\item[multi-panel plots] In this form, for each time step (selected)
a map is plotted in a separate panel, and the strip above the
panel indicates what the panel is about.  The panels share $x$-
and $y$-axis, no space needs to be lost by separating white space,
and a common legend is used. Three types are implemented for STFDF data:
\begin{itemize}
\item $x$ and $y$ axis denote space, an example for gridded data is
shown in figure \ref{fig:wind}, for polygon data in figure \ref{fig:produc}. 
The \code{stplot} is a wrapper around
\code{spplot} in package \code{sp}, and inherits most of its options.
\item $x$ and $y$ denote time and value; one panel for each spatial
feature, colors may indicate different variables (\code{mode="tp"});
see figure \ref{fig:tpts} (left)
\item $x$ and $y$ denote time and value; one panel for each variable,
colors may denote different features (\code{mode="ts"});
see figure \ref{fig:tpts} (right)
\end{itemize}
\item[space-time plots] space-time plots show data in a space-time
cross-section, with e.g., space on the $x$-axis and time on the
$y$-axis. (See also figure \ref{fig:st}.)

%R> pdf("ts.pdf")
%R> stplot(Produc.st[1:4,,c("pcap", "hwy", "water", "util")],mode="ts")
%R> pdf("tp.pdf")
%R> stplot(Produc.st[1:4,,c("pcap", "hwy", "water", "util")],mode="tp")

Hovm\"{o}ller diagrams \citep{hov} are an example of these for full space-time lattices,
i.e. objects of class \code{STFDF}.  To obtain such a plot, the
arguments \code{mode} and \code{scaleX} should be considered; some
special care is needed when only the x- or y-axis needs to be plotted 
instead of the spatial index (1...n); details are found in the \code{stplot}
documentation. An example of a Hovm\"{o}ller-style plot with station
index along the x-axis and time along the y-axis is obtained by
<<eval=FALSE>>=
scales=list(x=list(rot = 45))
stplot(w, mode = "xt", scales = scales, xlab = NULL)
@
and shown in figure \ref{fig:hov}. Note that the $y$-axis direction
is opposite to that of regular Hovm\"{o}ller plots.
\item[animated plots] Animation is another way of displaying change
over time; a sequence of \code{spplot}s, one for each time step,
is looped over when the parameter \code{animate} is set to a
positive value (indicating the time in seconds to pause between
subsequent plots).

\begin{figure}[htb]
\begin{center}
\includegraphics[scale=.6]{wind}
\end{center}
\caption{Space-time interpolations of wind (square root transformed,
detrended) over Ireland using a separable product covariance model,
for 10 time points regularly distributed over the month for which
daily data was considered (April, 1961).}
\label{fig:wind}
\end{figure}

\begin{figure}[htb]
\begin{center}
\includegraphics[width=.4\columnwidth]{tp}
\includegraphics[width=.4\columnwidth]{ts}
\end{center}
\caption{ Time series for four variables and four features plotted with \code{stplot},
with \code{mode="tp"} (left) and \code{mode="ts"} (right); see also section \ref{panel}. }
\label{fig:tpts}
\end{figure}

\begin{figure}[htb]
\begin{center}
\includegraphics[scale=.5]{hov}
\end{center}
\caption{Space-time (Hovm\"{o}ller) plot of wind station data.}
\label{fig:hov}
\end{figure}

\item[Time series plots]
Time series plots are a fairly common type of plot in \proglang{R}. 
Package \code{xts} has a plot method that 
allows univariate time series to be plotted. Many (if not most) plot
routines in \proglang{R} support time to be along the x- or y-axis.  
The plot in figure \ref{fig:windts} was generated by using package
\pkg{lattice} \citep{sarkar}, and uses a colour palette from package
\pkg{RColorBrewer} \citep{neuwirth}.

<<echo=FALSE,eval=FALSE,keep.source=TRUE>>=
# code to create figure 5.
library("lattice")
library("RColorBrewer")
b = brewer.pal(12, "Set3")
par.settings = list(superpose.symbol = list(col = b, fill = b), 
	superpose.line = list(col = b),
	fontsize = list(text=9)) 
stplot(w, mode = "ts",  auto.key=list(space="right"), 
	xlab = "1961", ylab = expression(sqrt(speed)),
	par.settings = par.settings)
@

\begin{figure}[htb]
\begin{center}
\includegraphics[scale=.8]{windts}
\end{center}
\caption{Time series plot of daily wind speed at 12 stations, used
for interpolation in figure \ref{fig:wind}.}
\label{fig:windts}
\end{figure}

\end{description}

\section{Spatial footprint or support, time intervals}

\subsection{Time periods or time instances}
\label{intervals}

Data structures for time series data in \proglang{R} have, explicitly
or implicitly, for each record a time stamp, not a time interval.
The implicit assumption seems to be (i) the time stamp is a moment,
(ii) this indicates either the real moment of measurement /
registration, or the start of the interval over which something is
aggregated (summed, averaged, maximized). For financial ``Open,
high, low, close'' data, the ``Open'' and ``Close'' refer to the
values at the moments the stock exchange opens and closes, meaning
time instances, whereas ``high'' and ``low'' are aggregated values
-- the minimum and maximum price over the time interval between
opening and closing times.

Package \code{lubridate} \citep{grolemund} allows one to explicitly
define and compute with time intervals (e.g., \cite{allen}). It
does not provide structures to attach these intervals to time
series data. As \pkg{xts} does not support these times as index,
\pkg{spacetime} does also not support it. 

According to \href{http://en.wikipedia.org/wiki/ISO_8601}{ISO 8601:2004},
a time stamp like "2010-05" refers to {\em the full} month of May,
2010, and so reflects a time period rather than a moment. As
a selection criterion, \code{xts} will include everything inside the
following interval:
<<>>=
.parseISO8601('2010-05')
@
and this syntax lets one define, unambiguously, yearly, monthly,
daily, hourly or minute intervals, but not e.g.~10- or 30-minute
intervals. For a particular interval, the full specification is needed:
<<>>=
.parseISO8601('2010-05-01T13:30/2010-05-01T13:39')
@

When matching two sequences of time (figure \ref{fig:ti}) in order
to overlay or aggregate, it matters whether each of the sequences
reflect instances, one of them reflects time intervals and the
other instances, or both reflect time intervals. All of the three
cases are accomodated for in package \pkg{spacetime}. 

Objects in \pkg{spacetime} do not explicitly register whether time
reflects to instances or intervals.  For matching (\code{over})
or aggregation, by default, objects with gridded space-time layout
(figure \ref{fig:st}) deriving from \code{STF} or \code{STS}
default to interval time, and other objects to instance time,
but this default can be overriden in calls to \code{over} and
\code{aggregate}. As only start times of time intervals are given,
the package makes the assumption that the last interval (for
which no end time instance is present) has the same length as the
one-but-last interval.

\begin{figure}[htb]
\begin{center}
\includegraphics[scale=1.1]{ti}
\end{center}
\caption{Matching two time sequences, assuming \code{x} reflects
time intervals, and \code{y} reflects time instances.  Note that the
last interval extends the last time instance of \code{x}.  }
\label{fig:ti}
\end{figure}

\subsection{Spatial support}

All examples above work with spatial points, i.e., data having a
point support. The assumption of data having points support is
implicit for \code{SpatialPoints} features.  For polygons, the
assumption will be that values reflect aggregates (e.g.  sums,
or averages) over the polygon. For gridded data, it is ambiguous
whether the value at the grid cell centre is meant (e.g. for
DEM data) or an aggregate over the grid cell (typical for remote
sensing imagery).  The \code{Spatial*} objects of package \pkg{sp}
have no {\em explicit} information about the spatial support.

% What if time intervals are irregular, and values denoting aggregate?
% What is the time interval for the last measurement?

% Time intervals, and their relationship; possibility of overlapping
% (duplicate) information.

% Anyway, how do we find/identify/deal with possibility of duplicates?

% Resampling?

% Spatial/temporal/spatio-temporal aggregation?

\section{Worked examples}
\label{sec:cases}

This Section shows how existing data in various formats can be
converted into ST classes, and how they can be analysed and/or
visualised.

\subsection{North Carolina SIDS}
\label{sec:nc}
As an example, the North Carolina Sudden Infant Death Syndrome (sids)
data \citep{sids} in package
\pkg{maptools} \citep{maptools} will be used; they are sparse in time (aggregated to 2 periods
of unequal length, according to the documentation in package \code{spdep}),
but have polygons in space. First, we will prepare the spatial data:
<<>>=
library("maptools")
fname = system.file("shapes/sids.shp", package="maptools")[1]
nc = readShapePoly(fname, proj4string=CRS("+proj=longlat +datum=NAD27"))
@
then, we construct the time sequence:
<<>>=
time = as.POSIXct(strptime(c("1974-01-01", "1979-01-01"), "%Y-%m-%d"), 
	tz = "GMT")
@
and finally we construct the data values table (in long form):
<<>>=
data = data.frame(
	BIR = c(nc$BIR74, nc$BIR79),
	NWBIR = c(nc$NWBIR74, nc$NWBIR79),
	SID = c(nc$SID74, nc$SID79))
@
These three components are put together by function \code{STFDF}:
<<>>=
nct = STFDF(sp = as(nc, "SpatialPolygons"), time = time, data = data)
@

\subsection{Panel data}
\label{panel}
The panel data discussed in Section \ref{sec:longwide} are imported
as a full spatio-temporal \code{data.frame} (\code{STFDF}), and
linked to the proper state polygons of maps.
We obtain the states polygons by:
<<>>=
library("maps")
states.m = map('state', plot=FALSE, fill=TRUE)
IDs <- sapply(strsplit(states.m$names, ":"), function(x) x[1])
library("maptools")
states = map2SpatialPolygons(states.m, IDs=IDs)
@
we obtain the time points by:
<<>>=
yrs = 1970:1986
time = as.POSIXct(paste(yrs, "-01-01", sep=""), tz = "GMT")
@
We obtain the data table (already in long format) by
<<>>=
library("plm")
data("Produc")
@
When combining all this information, we do not need to reorder states
because \code{states} and \code{Produc} 
order states alphabetically. We need to deselect District
of Columbia, which is not present in \code{Produc} table (record 8):
<<>>=
# deselect District of Columbia, polygon 8, which is not present in Produc:
Produc.st = STFDF(states[-8], time, Produc[order(Produc[2], Produc[1]),])
@
<<>>=
library(RColorBrewer)
stplot(Produc.st[,,"unemp"], yrs, col.regions = brewer.pal(9, "YlOrRd"),cuts=9)
@
produces the plot shown in Figure \ref{fig:produc}.

\begin{figure}[htb]
\begin{center}
\includegraphics[scale=.8]{produc}
\end{center}
\caption{Unemployment rate per state, over the years 1970-1986}
\label{fig:produc}
\end{figure}

Time and state were not removed from the data table on construction;
printing these data after coercion to \code{data.frame} can then
be used to verify that time and state were matched correctly. 

The routines in package \pkg{plm} can be used on the data, when back
transformed to a \code{data.frame}, when \code{index} is used to specify
which variables represent space and time (the first two columns
from the \code{data.frame} no longer contain state and year). For
instance, to fit a panel linear model for gross state products (gsp)
to private capital stock (pcap), public capital (pc), labor input
(emp) and unemployment rate (unemp), we get
<<>>=
zz <- plm(log(gsp) ~ log(pcap) + log(pc) + log(emp) + unemp, 
	data = as.data.frame(Produc.st), index = c("state","year"))
@
(the output of \code{summary(zz)} is left out for breveity).

\subsection{Interpolating Irish wind}
\label{sec:wind}

This worked example is a modified version of the analysis presented
in \code{demo(wind)} of package \pkg{gstat} \citep{pebesma04}. This
demo is rather lengthy and reproduces much of the original analysis
in \cite{haslett}.  Here, we will reduce the intermediate plots and
focus on the use of spatio-temporal classes.

First, we will load the wind data from package \code{gstat}. It
has two tables, station locations in a \code{data.frame}, called
\code{wind.loc}, and daily wind speed in \code{data.frame}
\code{wind}.  We now convert character representation (such as
\code{51d56'N}) to proper numerical coordinates, and convert the
station locations to a \code{SpatialPointsDataFrame} object. A plot of
these data is shown in figure \ref{fig:windloc}.
<<>>=
library("gstat")
data("wind")
wind.loc$y = as.numeric(char2dms(as.character(wind.loc[["Latitude"]])))
wind.loc$x = as.numeric(char2dms(as.character(wind.loc[["Longitude"]])))
coordinates(wind.loc) = ~x+y
proj4string(wind.loc) = "+proj=longlat +datum=WGS84"
@

\begin{figure}[htb]
\begin{center}
<<fig=TRUE,echo=FALSE>>=
library("mapdata")
plot(wind.loc, xlim = c(-11,-5.4), ylim = c(51,55.5), axes=T, col="red",
	cex.axis =.7)
map("worldHires", add=TRUE, col = grey(.5))
text(coordinates(wind.loc), pos=1, label=wind.loc$Station, cex=.7)
@
\end{center}
\caption{Station locations for Irish wind data.}
\label{fig:windloc}
\end{figure}

The first thing to do with the wind speed values is to reshape
these data. Unlike the North Carolina SIDS data of Section
\ref{sec:nc}, for we have few spatial and many time points, and
so the data in \code{data.frame} \code{wind} come in space-wide
form with stations time series in columns:
<<>>=
wind[1:3,]
@
We will recode the time columns to an appropriate time data 
structure, 
<<>>=
wind$time = ISOdate(wind$year+1900, wind$month, wind$day)
wind$jday = as.numeric(format(wind$time, '%j'))
@
and then subtract a smooth time trend of daily means (not
exactly equal, but similar to the trend removal in the original
paper):
<<>>=
stations = 4:15
windsqrt = sqrt(0.5148 * as.matrix(wind[stations])) # knots -> m/s
Jday = 1:366
windsqrt = windsqrt - mean(windsqrt)
daymeans = sapply(split(windsqrt, wind$jday), mean)
meanwind = lowess(daymeans ~ Jday, f = 0.1)$y[wind$jday]
velocities = apply(windsqrt, 2, function(x) { x - meanwind })
@
Next, we will match the wind data to its location, by connecting
station names to location coordinates, and create a spatial points
object:
<<>>=
wind.loc = wind.loc[match(names(wind[4:15]), wind.loc$Code),]
pts = coordinates(wind.loc[match(names(wind[4:15]), wind.loc$Code),])
rownames(pts) = wind.loc$Station
pts = SpatialPoints(pts, CRS("+proj=longlat +datum=WGS84"))
@
Then, we project
the longitude/latitude coordinates and country boundary to 
UTM zone 29, using \code{spTransform} in package
\pkg{rgdal} \citep{rgdal} for coordinate transformation:
<<>>=
library("rgdal")
utm29 = CRS("+proj=utm +zone=29 +datum=WGS84")
pts = spTransform(pts, utm29)
@
And now we can construct the spatio-temporal object from the space-wide table
with velocities:
<<>>=
w = stConstruct(velocities, space = list(values = 1:ncol(velocities)), 
	time = wind$time, SpatialObj = pts)
class(w)
@
For plotting purposes, we can obtain country boundaries from package \pkg{maps}:
<<>>=
library("maptools")
m = map2SpatialLines(
	map("worldHires", xlim = c(-11,-5.4), ylim = c(51,55.5), plot=F))
proj4string(m) = "+proj=longlat +datum=WGS84"
m = spTransform(m, utm29)
@
For interpolation, we can define a grid over the area:
<<>>=
grd = SpatialPixels(SpatialPoints(makegrid(m, n = 300)),
	proj4string = proj4string(m))
@
Next, we (arbitrarily) restrict observations to those of April 1961:
<<>>=
w = w[, "1961-04"]
@
and choose 10 time points from that period 
to form the spatio-temporal prediction grid:
<<>>=
n = 10
tgrd = xts(1:n, seq(min(index(w)), max(index(w)), length=n))
pred.grd = STF(grd, tgrd)
@
We will interpolate with a
separable exponential covariance model, with ranges 750 km and 1.5 days:
<<>>=
v = list(space = vgm(0.6, "Exp", 750000), time = vgm(1, "Exp", 1.5 * 3600 * 24))
pred = krigeST(values ~ 1, w, pred.grd, v)
wind.ST = STFDF(grd, tgrd, data.frame(sqrt_speed = pred))
@
then creates the \code{STFDF} object with interpolated values,
the results of which are shown in figure \ref{fig:wind}, created
by
<<eval=FALSE>>=
layout = list(list("sp.lines", m, col='grey'),
	list("sp.points", pts, first=F, cex=.5))
stplot(wind.ST, col.regions=brewer.pal(11, "RdBu")[-c(10,11)],
	at=seq(-1.375,1,by=.25),
	par.strip.text = list(cex=.7), sp.layout = layout)
@

<<eval=FALSE,echo=FALSE>>=
pdf("wind.pdf")
layout = list(list("sp.lines", m, col='grey'),
	list("sp.points", pts, first=F, cex=.5))
print(stplot(wind.ST, col.regions=brewer.pal(11, "RdBu")[-c(10,11)],
	at=seq(-1.375,1,by=.25),
	par.strip.text = list(cex=.7), sp.layout = layout))
dev.off()
@

<<eval=FALSE,echo=FALSE>>=
pdf("windts.pdf")
library("lattice")
library("RColorBrewer")
b = brewer.pal(12,"Set3")
par.settings = list(superpose.symbol = list(col = b, fill = b), 
	superpose.line = list(col = b),
	fontsize = list(text=9)) 
print(stplot(w, mode = "ts",  auto.key=list(space="right"), 
	xlab = "1961", ylab = expression(sqrt(speed)),
	par.settings = par.settings))
dev.off()
@

<<eval=FALSE,echo=FALSE>>=
pdf("hov.pdf")
scales=list(x=list(rot=45))
stplot(w, mode = "xt", scales = scales, xlab = NULL, 
	col.regions=brewer.pal(11, "RdBu"),at = seq(-1.625,1.125,by=.25))
dev.off()
@

\subsection{Calculation of EOFs}
Empirical orthogonal functions from \code{STFDF} objects can be
computed in spatial form (default):
<<eval=FALSE>>=
eof.sp = EOF(wind.ST)
@
or in temporal form by:
<<eval=FALSE>>=
eof.xts = EOF(wind.ST, "temporal")
@
the resulting object is of the appropriate subclass of \code{Spatial}
in the spatial form, or of class \code{xts} in the temporal
form. Figure \ref{fig:eof} shows the 10 spatial EOFs obtained from
the interpolated wind data of figure \ref{fig:wind}.

\begin{figure}[htb]
\begin{center}
<<echo=FALSE,fig=TRUE,height=3.5,width=5>>=
print(spplot(EOF(wind.ST), col.regions=bpy.colors(),
	par.strip.text = list(cex=.5), as.table = TRUE))
@
\end{center}
\caption{EOFs of space-time interpolations of wind over Ireland
(for spatial reference, see figure \ref{fig:wind}), for the 10 time
points at which daily data was chosen above (April, 1961).}
\label{fig:eof}
\end{figure}

\subsection{Conversion from and to trip}

Objects of class \code{trip} in package \pkg{trip} \citep{sumner},
meant to represent trajectories, extend objects of class
\code{SpatialPointsDataFrame} by indicating in which data value
columns time and trip ID are, in slot \code{TOR.columns}. To not
lose this information (in particular, which column contains the IDs),
we will extend class \code{STIDF} to retain this info.

The following example uses data from package \pkg{diveMove} \citep{luque}.
It assumes that time in a trip object is ordered, as \pkg{xts}
will order it otherwise.

We first prepare the trip object:
<<>>=
library("diveMove")
library("trip")
data(sealLocs, package="diveMove")
sealLocs$time = as.POSIXct(sealLocs$time)
ringy = subset(sealLocs, id == "ringy" & !is.na(lon) & !is.na(lat))
coordinates(ringy) = ringy[c("lon", "lat")]
tr = trip(ringy, c("time", "id"))
@
Next, we convert it into an \code{STTDF} object, and plot it:
<<>>=
setAs("trip", "STTDF",
	function(from) {
		from$burst = from[[from@TOR.columns[2]]]
		time = from[[from@TOR.columns[1]]]
		#from = from[order(time),]
        STIbox = STI(SpatialPoints(t(bbox(from))), range(time))
		STT = new("STT", STIbox, traj = list(STI(geometry(from), time)))
		new("STTDF", STT, data = from@data)
	}
)
x = as(tr, "STTDF")
m = map2SpatialLines(map("world", 
	xlim = c(-100,-50), ylim = c(40,77), plot=F))
proj4string(m) = "+proj=longlat +datum=WGS84"
plot(m, axes=TRUE, cex.axis =.7)
plot(x, add=TRUE, col = "red")
@
the resulting plot is shown in figure \ref{fig:trip}.

\begin{figure}[htb]
<<fig=TRUE,height=4,width=4,echo=FALSE>>=
plot(m, axes=TRUE, cex.axis =.7)
plot(x, add=TRUE, col = "red")
@
\caption{ Trajectory, formed by satellite locations of a ringed
seal caught and released in New York. }

\label{fig:trip}
\end{figure}

\subsection[Trajectory data: ltraj in adehabitatLT]{Trajectory data:
\code{ltraj} in package \pkg{adehabitatLT}}

Trajectory objects of class \code{ltraj} in package
\pkg{adehabitatLT} \citep{calenge} are lists of bursts, sets
of sequential, connected space-time points at which an object
is registered.  An example \code{ltraj} data set is obtained 
by\footnote{taken from \pkg{adehabitatLT}, \code{demo(mangltraj)}}:
<<>>=
library("adehabitatLT")
data("puechabonsp")
locs = puechabonsp$relocs
xy = coordinates(locs)
da = as.character(locs$Date)
da = as.POSIXct(strptime(as.character(locs$Date),"%y%m%d"), tz = "GMT") 
ltr = as.ltraj(xy, da, id = locs$Name)
foo = function(dt) dt > 100*3600*24
l2 = cutltraj(ltr, "foo(dt)", nextr = TRUE)
@
and these data, converted to \code{STTDF} can be plotted, as
panels by \code{time} and \code{id} by
<<eval=FALSE>>=
sttdf = as(l2, "STTDF")
stplot(sttdf, by="time*id")
@
which is shown in figure \ref{fig:stptr}. 

\begin{figure}[htb]
\begin{center}
<<echo=FALSE,fig=TRUE,height=5.5,width=5.5>>=
sttdf = as(l2, "STTDF")
print(stplot(sttdf, by="time*id"))
@
\end{center}
\caption{Trajectories, split by id (rows) and by time (columns).}
\label{fig:stptr}
\end{figure}

\subsection{Country shapes in cshapes}

The \pkg{cshapes} \citep{weidmann} package contains a GIS dataset of country
boundaries (1946-2008), and includes functions for data extraction
and the computation of distance matrices. The data set consist of
a \code{SpatialPolygonsDataFrame}, with the following data variables:
<<>>=
library("cshapes")
cs = cshp()
names(cs)
@
where two data bases are used, ``COW'' (correlates of war
project\footnote{Correlates of War Project. 2008. State System
Membership List, v2008.1. Online, \url{http://correlatesofwar.org/}})
and ``GW'' \cite{gleditsch}. The variables COWSMONTH and COWEMONTH
denote the start month and end month, respectively, according to
the COW data base.

To select the country boundaries corresponding to a particular date
and classification system, one can use
<<>>=
cshp.2002 <- cshp(date=as.Date("2002-6-30"), useGW=TRUE)
@

In the following fragment, we create the time index:
<<>>=
t = as.POSIXct(strptime(paste(cs$COWSYEAR, 
	cs$COWSMONTH,cs$COWSDAY, sep="-"), "%Y-%m-%d"), tz = "GMT")
@
and the spatio-temporal object:
<<>>=
st = STIDF(geometry(cs), t, as.data.frame(cs))
@
A possible query would be which countries are found at 7\textdegree East
and 52\textdegree North,
<<>>=
pt = SpatialPoints(cbind(7, 52), CRS(proj4string(cs)))
as.data.frame(st[pt,,1:5])
@
which turns out to be Western Germany and Germany, before and after
the merge. No data before 1955-5-5 is available.

\section{Further material}

Searching past email discussion threads on the
\href{https://stat.ethz.ch/mailman/listinfo/r-sig-geo}{\code{r-sig-geo}}
(R Special Interest Group on using GEOgraphical data and Mapping)
email list may be a good way to look for further material, before
one considers posting questions. Search strings, e.g. on the google
search engine may look like:

\code{spacetime site:stat.ethz.ch}

where the search keywords should be made more precise.

The following subsections indicate further material that forms part
of the \pkg{spacetime} package.

\subsection{Statistics for spatio-temporal data}

The data sets that are provided by \cite{cressie}, as well as a number of plots 
presented there, are obtained by
<<eval=FALSE>>=
library(spacetime)
demo(CressieWikle)
@
This demo script downloads the data from the book web site, and
reproduces a number of graphs from them, shown in the book. It should
be noted that the the book examples only deal with \code{STFDF}
objects.

Section \ref{sec:wind} contains an example of a spatial interpolation
with a spatio-temporal separable or or product-sum covariance
model. The functions for this are found in package \pkg{gstat},
and more information is found through

<<eval=FALSE>>=
library(gstat)
vignette("st")
@

\subsection{Data base connections}

An example where (potentially large) data sets are proxied through
R objects is given in a vignette in the \pkg{spacetime} package, obtained
by
<<eval=FALSE>>=
library(spacetime)
vignette("stpg")
@
A proxy object is an object that contains no data, but only
references to tables in a data base. Selections on this object are
translated into SQL statements that return the actually selected
data.  This way, the complete data set does not have to be loaded
in memory (R), but can be analyzed part by part. Selection in the
data base uses indexes on the spatial and temporal references.

\subsection{Overlay and aggregation}
\label{overlay}
Examples of overlay and aggregation methods for spatio-temporal data
are further detailed in a separate vignette, obtained by
<<eval=FALSE>>=
library(spacetime)
vignette("sto")
@
It illustrates the methods with daily air quality data taken from
the European air quality data base, for 1998-2009. Aggregations
are temporal, and spatial, and both.

%<<>>=
%http://www.nws.noaa.gov/geodata/catalog/national/data/s_01au07.zip
%@

% \section{TODO}

% write aggregate for all 3? aggregate over time -> defer to xts?
% split method for STIDF

% write tests for points, lines, polygons, pixels, grid

% How to do spatial selection for grids - use index, or c(rows,cols)
% as spatial selector?

% xts: aggregate, shift to nearest grid point,

% s/t: overlay? (where,when)->index of values available? xts accepts
% time index, sp will need overlay.

% generic: plot, 

% DONE:
% summary, show (automatic), spTransform (NOT: requires rgdal dependency),
% stplot (as function)

% Plotting methods: stplot -> interface to spplot with panel for
% each time step (single attribute), or double with [attribute, time]
% as panel entries.

% plot -> plot.xts/plot.zoo interface?
% 
% plot time series with little maps (micromaps) indicating region/point? ggplot?

% plot maps with little time series plotted at particular points?

% \subsection{coercion to external classes}
% spatial panel model.

\section{Discussion}

Handling and analyzing spatio-temporal data is often complicated
by the size and complexity of these data. Also, data may come in
many different forms, may be time-rich, space-rich, as sets of
space-time points or as trajectories.

Building on existing infrastructure for spatial and temporal
data, we have successfully implemented a coherent set of classes
for spatio-temporal data that covers regular space-time layouts,
partially regular (sparse) space-time layouts, irregular space-time
layouts and trajectory data. The set is flexible in the sense that
several representations of space (points, lines, polygons, grid)
and time (POSIXt, Date, timeDate, yearmon, yearqtr) can be combined.

We have given examples for constructing objects of these classes from
various data sources, coercing them from one to another, exporting
them to spatial or temporal representations, as well as visualising
them in various forms. We have also shown how one can go from one
form into another by ways of prediction based on a statistical model,
using an example on spatio-temporal geostatistical interpolation.
In addition to spatio-temporally varying information, objects of
the classes can contain data values that are purely spatial or
purely temporal. Selection can be done based on spatial features,
time (intervals), or data variables, and follows a logic similar
to that for selection on data tables (\code{data.frame}s).

Using existing infrastructure had the consequence that data that
refer to time {\em intervals} are stored with a (start) time instance
only. This may seem incomplete, but seems to reflect current practice
in time series analysis. It limits the covered cases to those with
non-overlapping time intervals.

Challenges that remain include
\begin{itemize}
\item the representation of spatio-temporal polygons in a consistent
way, i.e. such that each point in space-time refers to one and only
one space-time feature
\item dealing with complex developments, such as merging, splitting,
and death and birth of objects (further examples are found in \cite{galton})
\item explicitly registring the support, or footprint of spatio-temporal
data
\item annotating objects such that incorrect operations (such as the interpolation
of a point process, or the weighted density estimates on a geostatitical process)
can lead to warning or error messages
\item making handling of massive data sets easier, and implementing efficient
spatio-temporal indexes for them
\item integrating package \pkg{spacetime} with other packages
dealing with specific spatio-temporal classes such as \pkg{raster} and
\pkg{surveillance}.
\end{itemize}

The classes and methods presented in this paper are a first attempt
to cover a number of useful cases for spatio-temporal data. In
a set of case studies it is demonstrated how they can be used,
and can be useful. As software development is often opportunistic,
we admittedly picked a lot of low hanging fruits, and a number of
large challenges remain. We hope that these first steps will help
discovering and identifying these more complex use cases.

\section*{Acknowledgements}
Michael Sumner provided helpful comments on the trip example.
Members from the spatio-temporal modelling lab of the Institute for
Geoinformatics of the University of M\"{u}nster (Ben Gr\"{a}ler,
Katharina Henneb\"{o}hl, Daniel N\"{u}st), and S\"{o}ren Gebbert
contributed in several useful discussions. Participants to
the workshop {\em Handling and analyzing spatio-temporal data
in \proglang{R}}, held in M\"{u}nster on Mar 21-22, 2011, are
gratefully acknowledged.

\bibliography{spacetime}

\end{document}
